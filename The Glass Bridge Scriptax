-- Intentar cargar la librería Rayfield
local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://sirius.menu/rayfield', true))()
end)

-- Verificar si Rayfield se cargó correctamente
if not success or not Rayfield then
    warn("Error al cargar Rayfield desde https://sirius.menu/rayfield. Ejecución sin UI.")
    -- Script de respaldo sin UI
    for _, step in pairs(workspace:GetChildren()) do
        if step.Name == "Step" and step:IsA("Model") then
            local glassTempered = step:FindFirstChild("glass_tempered")
            if glassTempered then
                for _, part in pairs(glassTempered:GetDescendants()) do
                    if part:IsA("BasePart") or part:IsA("MeshPart") then
                        part.Color = Color3.fromRGB(0, 255, 0) -- Verde neón
                        part.Material = Enum.Material.Neon
                    end
                end
            end
        end
    end
    print("Coloreado completado: glass_tempered (verde neón).")
else
    -- Notificación inicial para confirmar carga
    Rayfield:Notify({
        Title = "Scriptax HUB",
        Content = "¡Bienvenido a Scriptax HUB! Menú de colores cargado correctamente.",
        Duration = 5,
        Image = "rbxassetid://4483345998"
    })

    -- Servicios
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    -- Función para crear la ventana
    local function createWindow()
        local Window = Rayfield:CreateWindow({
            Name = "Menú de Colores | Scriptax",
            LoadingTitle = "Cargando...",
            LoadingSubtitle = "por Estardax",
            ShowText = "Abrir Menú",
            Theme = "Serenity",
            ToggleUIKeybind = "G",
            KeySystem = false,
            ConfigurationSaving = { 
                Enabled = true, 
                FolderName = "ScriptaxConfig", 
                FileName = "GlassColorConfig" 
            }
        })

        -- ================== VARIABLES COMPARTIDAS ==================
        local glassEspEnabled = false
        local originalTempered = {} -- [part] = {Color=..., Material=...}
        local GlassEspToggle = nil -- Referencia al toggle de ESP
        local floatingEspButton = nil -- Referencia al botón flotante de ESP
        local floatingCorrectButton = nil -- Referencia al botón flotante de Correct All
        local floatingEspButtonToggle = nil -- Referencia al toggle de botón flotante ESP
        local floatingCorrectButtonToggle = nil -- Referencia al toggle de botón flotante Correct All
        local espStroke = nil -- Referencia al borde del botón ESP
        local correctStroke = nil -- Referencia al borde del botón Correct All
        local childAddedConnection = nil -- Conexión para ChildAdded
        local heartbeatConnection = nil -- Conexión para Heartbeat

        -- Conexión para pasos dinámicos
        childAddedConnection = workspace.ChildAdded:Connect(function(child)
            if child.Name == "Step" and child:IsA("Model") then
                task.wait(0.5) -- Esperar a que se carguen los hijos
                if glassEspEnabled then
                    applyToStepEsp(child)
                    print("Debug: Aplicando ESP a nuevo Step: " .. child.Name)
                end
            end
        end)

        -- Aplicar ESP a un solo paso
        local function applyToStepEsp(step)
            local glassTempered = step:FindFirstChild("glass_tempered")
            if not glassTempered then
                glassTempered = step:WaitForChild("glass_tempered", 1) -- Esperar con timeout
            end
            if glassTempered then
                for _, part in pairs(glassTempered:GetDescendants()) do
                    if (part:IsA("BasePart") or part:IsA("MeshPart")) and part:IsDescendantOf(workspace) then
                        if not originalTempered[part] then
                            originalTempered[part] = { Color = part.Color, Material = part.Material }
                        end
                        part.Color = Color3.fromRGB(0, 255, 0) -- Verde neón
                        part.Material = Enum.Material.Neon
                    end
                end
                print("Debug: ESP aplicado a glass_tempered en " .. step.Name)
            else
                warn("Debug: No se encontró glass_tempered en " .. step.Name)
            end
        end

        -- Aplicar ESP a todos los pasos actuales
        local function applyGlassEsp()
            for _, step in pairs(workspace:GetChildren()) do
                if step.Name == "Step" and step:IsA("Model") then
                    applyToStepEsp(step)
                end
            end
        end

        -- Resetear ESP
        local function resetGlassEsp()
            for part, props in pairs(originalTempered) do
                if part and part:IsDescendantOf(workspace) then
                    part.Color = props.Color
                    part.Material = props.Material
                end
            end
            print("Debug: ESP reseteado a colores originales")
        end

        -- Limpiar originalTempered para partes destruidas
        local function cleanOriginalTempered()
            for part in pairs(originalTempered) do
                if not part:IsDescendantOf(workspace) then
                    originalTempered[part] = nil
                end
            end
        end

        -- Chequeo periódico para reaplicar ESP y limpiar
        local lastCheckTime = 0
        local checkInterval = 2 -- Cada 2 segundos
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            if glassEspEnabled and os.clock() - lastCheckTime >= checkInterval then
                lastCheckTime = os.clock()
                cleanOriginalTempered() -- Limpiar partes destruidas
                applyGlassEsp() -- Reaplicar ESP a nuevos pasos
                print("Debug: Reaplicando ESP vía Heartbeat")
            end
        end)

        -- Función para colorear glass_weak y destruir detectores
        local function executeCorrectAll()
            for _, step in pairs(workspace:GetChildren()) do
                if step.Name == "Step" and step:IsA("Model") then
                    local glassWeak = step:FindFirstChild("glass_weak")
                    if glassWeak then
                        for _, part in pairs(glassWeak:GetDescendants()) do
                            if part:IsA("BasePart") or part:IsA("MeshPart") then
                                part.Color = Color3.fromRGB(0, 0, 255) -- Azul neón
                                part.Material = Enum.Material.Neon
                            end
                        end
                        local detector = glassWeak:FindFirstChild("Detector")
                        if detector then
                            detector:Destroy()
                        end
                    end
                end
            end
            Rayfield:Notify({
                Title = "Éxito",
                Content = "glass_weak coloreado en azul neón y detectores destruidos.",
                Duration = 3,
                Image = "rbxassetid://4483345998"
            })
        end

        -- Alternar ESP
        local function toggleGlassEsp()
            glassEspEnabled = not glassEspEnabled
            if GlassEspToggle then GlassEspToggle:Set(glassEspEnabled) end
            if glassEspEnabled then
                applyGlassEsp()
                if espStroke then
                    espStroke.Color = Color3.fromRGB(0, 255, 0)
                end
                Rayfield:Notify({
                    Title = "Éxito",
                    Content = "glass_tempered (verde neón) activado.",
                    Duration = 3,
                    Image = "rbxassetid://4483345998"
                })
            else
                resetGlassEsp()
                if espStroke then
                    espStroke.Color = Color3.fromRGB(0, 0, 0)
                end
                Rayfield:Notify({
                    Title = "Reset",
                    Content = "glass_tempered reseteado a colores originales.",
                    Duration = 3,
                    Image = "rbxassetid://4483345998"
                })
            end
        end

        -- Crear botón flotante de ESP
        local function createFloatingEspButton()
            if floatingEspButton then return end

            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            screenGui.IgnoreGuiInset = true
            screenGui.ResetOnSpawn = false

            floatingEspButton = Instance.new("Frame")
            floatingEspButton.Size = UDim2.new(0, 50, 0, 50)
            floatingEspButton.Position = UDim2.new(0.4, 0, 0.5, 0)
            floatingEspButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            floatingEspButton.BorderSizePixel = 0
            floatingEspButton.Parent = screenGui

            local uiCorner = Instance.new("UICorner")
            uiCorner.CornerRadius = UDim.new(1, 0)
            uiCorner.Parent = floatingEspButton

            espStroke = Instance.new("UIStroke")
            espStroke.Thickness = 2
            espStroke.Color = glassEspEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(0, 0, 0)
            espStroke.Parent = floatingEspButton

            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.Text = "ESP"
            textLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.TextSize = 14
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.Parent = floatingEspButton

            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.Parent = floatingEspButton
            button.MouseButton1Click:Connect(toggleGlassEsp)

            -- Hacerlo arrastrable
            local dragging = false
            local dragInput, dragStart, startPos

            local function update(input)
                local delta = input.Position - dragStart
                floatingEspButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end

            button.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    dragStart = input.Position
                    startPos = floatingEspButton.Position
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            dragging = false
                        end
                    end)
                end
            end)

            button.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    dragInput = input
                end
            end)

            UserInputService.InputChanged:Connect(function(input)
                if input == dragInput and dragging then
                    update(input)
                end
            end)
        end

        -- Crear botón flotante de Correct All
        local function createFloatingCorrectButton()
            if floatingCorrectButton then return end

            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            screenGui.IgnoreGuiInset = true
            screenGui.ResetOnSpawn = false

            floatingCorrectButton = Instance.new("Frame")
            floatingCorrectButton.Size = UDim2.new(0, 50, 0, 50)
            floatingCorrectButton.Position = UDim2.new(0.6, 0, 0.5, 0)
            floatingCorrectButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            floatingCorrectButton.BorderSizePixel = 0
            floatingCorrectButton.Parent = screenGui

            local uiCorner = Instance.new("UICorner")
            uiCorner.CornerRadius = UDim.new(1, 0)
            uiCorner.Parent = floatingCorrectButton

            correctStroke = Instance.new("UIStroke")
            correctStroke.Thickness = 2
            correctStroke.Color = Color3.fromRGB(0, 0, 0)
            correctStroke.Parent = floatingCorrectButton

            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.Text = "ALL"
            textLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.TextSize = 14
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.Parent = floatingCorrectButton

            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.Parent = floatingCorrectButton
            button.MouseButton1Click:Connect(function()
                executeCorrectAll()
                correctStroke.Color = Color3.fromRGB(0, 255, 0)
                task.wait(0.5)
                correctStroke.Color = Color3.fromRGB(0, 0, 0)
            end)

            -- Hacerlo arrastrable
            local dragging = false
            local dragInput, dragStart, startPos

            local function update(input)
                local delta = input.Position - dragStart
                floatingCorrectButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end

            button.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    dragStart = input.Position
                    startPos = floatingCorrectButton.Position
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            dragging = false
                        end
                    end)
                end
            end)

            button.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    dragInput = input
                end
            end)

            UserInputService.InputChanged:Connect(function(input)
                if input == dragInput and dragging then
                    update(input)
                end
            end)
        end

        -- Destruir botón flotante de ESP
        local function destroyFloatingEspButton()
            if floatingEspButton then
                floatingEspButton.Parent:Destroy()
                floatingEspButton = nil
                espStroke = nil
            end
        end

        -- Destruir botón flotante de Correct All
        local function destroyFloatingCorrectButton()
            if floatingCorrectButton then
                floatingCorrectButton.Parent:Destroy()
                floatingCorrectButton = nil
                correctStroke = nil
            end
        end

        -- Recrear botones flotantes al respawnear
        LocalPlayer.CharacterAdded:Connect(function()
            task.wait(2)
            if floatingEspButtonToggle and floatingEspButtonToggle.CurrentValue then
                createFloatingEspButton()
            end
            if floatingCorrectButtonToggle and floatingCorrectButtonToggle.CurrentValue then
                createFloatingCorrectButton()
            end
            if glassEspEnabled then
                applyGlassEsp()
            end
        end)

        -- Limpieza al cerrar el script
        game:BindToClose(function()
            if childAddedConnection then
                childAddedConnection:Disconnect()
            end
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end
            resetGlassEsp()
            destroyFloatingEspButton()
            destroyFloatingCorrectButton()
        end)

        -- =================== PESTAÑA: PRINCIPAL ===================
        local TabMain = Window:CreateTab("Principal", "layers")
        TabMain:CreateSection("Coloreado de Vidrio")
        GlassEspToggle = TabMain:CreateToggle({
            Name = "ESP de Vidrio",
            CurrentValue = false,
            Flag = "Glass_ESP",
            Callback = function(v)
                glassEspEnabled = v
                if v then
                    applyGlassEsp()
                    if espStroke then
                        espStroke.Color = Color3.fromRGB(0, 255, 0)
                    end
                    Rayfield:Notify({
                        Title = "Éxito",
                        Content = "glass_tempered (verde neón) activado.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                else
                    resetGlassEsp()
                    if espStroke then
                        espStroke.Color = Color3.fromRGB(0, 0, 0)
                    end
                    Rayfield:Notify({
                        Title = "Reset",
                        Content = "glass_tempered reseteado a colores originales.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                end
            end,
        })

        TabMain:CreateSection("Corregir Todo")
        TabMain:CreateButton({
            Name = "Ejecutar Corregir Todo",
            Callback = executeCorrectAll
        })

        TabMain:CreateSection("Configuración")
        TabMain:CreateLabel("Los ajustes se guardan manualmente en el juego.")

        -- ================= PESTAÑA: MÓVIL =================
        local TabMobile = Window:CreateTab("Móvil", "smartphone")
        TabMobile:CreateSection("Botones Flotantes")
        floatingEspButtonToggle = TabMobile:CreateToggle({
            Name = "Botón ESP",
            CurrentValue = false,
            Flag = "Floating_ESP_Button",
            Callback = function(v)
                if v then
                    createFloatingEspButton()
                    Rayfield:Notify({
                        Title = "Éxito",
                        Content = "Botón flotante de ESP activado.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                else
                    destroyFloatingEspButton()
                    Rayfield:Notify({
                        Title = "Éxito",
                        Content = "Botón flotante de ESP desactivado.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                end
            end,
        })

        floatingCorrectButtonToggle = TabMobile:CreateToggle({
            Name = "Botón Corregir Todo",
            CurrentValue = false,
            Flag = "Floating_Correct_Button",
            Callback = function(v)
                if v then
                    createFloatingCorrectButton()
                    Rayfield:Notify({
                        Title = "Éxito",
                        Content = "Botón flotante de Cor-Botón Corregir Todo activado.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                else
                    destroyFloatingCorrectButton()
                    Rayfield:Notify({
                        Title = "Éxito",
                        Content = "Botón flotante de Corregir Todo desactivado.",
                        Duration = 3,
                        Image = "rbxassetid://4483345998"
                    })
                end
            end,
        })

        -- ================= PESTAÑA: TECLAS =================
        local TabKeys = Window:CreateTab("Teclas", "keyboard")
        TabKeys:CreateSection("Atajos Personalizados")
        TabKeys:CreateKeybind({
            Name = "Alternar ESP de Vidrio",
            CurrentKeybind = "E",
            HoldToInteract = false,
            Flag = "Keybind_GlassESP",
            Callback = toggleGlassEsp
        })
        TabKeys:CreateKeybind({
            Name = "Ejecutar Corregir Todo",
            CurrentKeybind = "R",
            HoldToInteract = false,
            Flag = "Keybind_CorrectAll",
            Callback = executeCorrectAll
        })
        TabKeys:CreateLabel("Presiona G para abrir/cerrar el menú")
        TabKeys:CreateLabel("Por defecto: E para ESP de Vidrio, R para Corregir Todo")

        -- ================= PESTAÑA: CRÉDITOS =================
        local TabCredits = Window:CreateTab("Créditos", "award")
        TabCredits:CreateSection("Información del Script")
        TabCredits:CreateLabel("Menú de Colores | Hecho por Estardax ⚡")
        TabCredits:CreateLabel("Interfaz por Rayfield Library")
        TabCredits:CreateLabel("Scriptax HUB - Herramientas Avanzadas para Puente de Vidrio")

        return Window
    end

    -- Crear ventana con manejo de errores
    local successWindow, Window = pcall(createWindow)
    if not successWindow then
        warn("Error al crear la ventana de Rayfield: " .. tostring(Window))
        Rayfield:Notify({
            Title = "Error",
            Content = "No se pudo crear el menú. Verifica la consola para más detalles.",
            Duration = 5,
            Image = "rbxassetid://4483345998"
        })
    else
        print("Debug: Ventana creada correctamente")
    end
end
